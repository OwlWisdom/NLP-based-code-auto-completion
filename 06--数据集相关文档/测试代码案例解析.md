# 测试代码案例解析

1、快速排序

输入：

```python
def quicksort(filename):
    """Fast sorting of lists by value size"""
```

InCoder输出：

```python
def quicksort(filename):
    """Fast sorting of lists by value size"""
    with open(filename) as infile:
        data = infile.readlines()
    data = sorted(data, key=lambda x: (len(x), x))
    left, right = [], []
    pivot = data[0]
    left.append(pivot)
    for entry in data[1:]:
        if len(entry) > len(pivot):
            right.append(entry)
        else:
            left.append(entry)
```

Copilot输出：

```python
def quicksort(filename):
    """Fast sorting of lists by value size"""
    with open(filename, 'r') as f:
        lines = f.readlines()
    lines = [line.strip() for line in lines]
    lines = [line.split(',') for line in lines]
    lines = [[int(x) for x in line] for line in lines]
    lines = np.array(lines)
    np.random.shuffle(lines)
    return lines
```

codegen-2B输出：

```python
def quicksort(filename):  # Fast sorting of lists by value size
    with open(filename, 'r') as f:
        data = f.readlines()
    data = [int(x.strip()) for x in data]
    data.sort()
    return data
```



# MBPP测试基准

原链接地址：

- [MBPP](https://github.com/google-research/google-research/tree/master/mbpp)

```json
{
    {
        "text": "Write a function to find the minimum cost path to reach (m, n) from (0, 0) for the given cost matrix cost[][] and a position (m, n) in cost[][].",
        "code": "R = 3\r\nC = 3\r\ndef min_cost(cost, m, n): \r\n\ttc = [[0 for x in range(C)] for x in range(R)] \r\n\ttc[0][0] = cost[0][0] \r\n\tfor i in range(1, m+1): \r\n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \r\n\tfor j in range(1, n+1): \r\n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \r\n\tfor i in range(1, m+1): \r\n\t\tfor j in range(1, n+1): \r\n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \r\n\treturn tc[m][n]",
        "task_id": 1,
        "test_setup_code": "",
        "test_list": [
            "assert min_cost([[1, 2, 3], [4, 8, 2], [1, 5, 3]], 2, 2) == 8",
            "assert min_cost([[2, 3, 4], [5, 9, 3], [2, 6, 4]], 2, 2) == 12",
            "assert min_cost([[3, 4, 5], [6, 10, 4], [3, 7, 5]], 2, 2) == 16"
        ],
        "challenge_test_list": []
    }
        {
        "text": "Write a function to find the similar elements from the given two tuple lists.",
        "code": "def similar_elements(test_tup1, test_tup2):\r\n  res = tuple(set(test_tup1) & set(test_tup2))\r\n  return (res) ",
        "task_id": 2,
        "test_setup_code": "",
        "test_list": [
            "assert similar_elements((3, 4, 5, 6),(5, 7, 4, 10)) == (4, 5)",
            "assert similar_elements((1, 2, 3, 4),(5, 4, 3, 7)) == (3, 4)",
            "assert similar_elements((11, 12, 14, 13),(17, 15, 14, 13)) == (13, 14)"
        ],
        "challenge_test_list": []
    }
        {
        "text": "Write a python function to identify non-prime numbers.",
        "code": "import math\r\ndef is_not_prime(n):\r\n    result = False\r\n    for i in range(2,int(math.sqrt(n)) + 1):\r\n        if n % i == 0:\r\n            result = True\r\n    return result",
        "task_id": 3,
        "test_setup_code": "",
        "test_list": [
            "assert is_not_prime(2) == False",
            "assert is_not_prime(10) == True",
            "assert is_not_prime(35) == True"
        ],
        "challenge_test_list": []
    }
        {
        "text": "Write a function to find the largest integers from a given list of numbers using heap queue algorithm.",
        "code": "import heapq as hq\r\ndef heap_queue_largest(nums,n):\r\n  largest_nums = hq.nlargest(n, nums)\r\n  return largest_nums",
        "task_id": 4,
        "test_setup_code": "",
        "test_list": [
            "assert heap_queue_largest( [25, 35, 22, 85, 14, 65, 75, 22, 58],3)==[85, 75, 65] ",
            "assert heap_queue_largest( [25, 35, 22, 85, 14, 65, 75, 22, 58],2)==[85, 75] ",
            "assert heap_queue_largest( [25, 35, 22, 85, 14, 65, 75, 22, 58],5)==[85, 75, 65, 58, 35]"
        ],
        "challenge_test_list": []
    }
        {
        "text": "Write a function to find the number of ways to fill it with 2 x 1 dominoes for the given 3 x n board.",
        "code": "def count_ways(n): \r\n\tA = [0] * (n + 1) \r\n\tB = [0] * (n + 1) \r\n\tA[0] = 1\r\n\tA[1] = 0\r\n\tB[0] = 0\r\n\tB[1] = 1\r\n\tfor i in range(2, n+1): \r\n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \r\n\t\tB[i] = A[i - 1] + B[i - 2] \r\n\treturn A[n] ",
        "task_id": 5,
        "test_setup_code": "",
        "test_list": [
            "assert count_ways(2) == 3",
            "assert count_ways(8) == 153",
            "assert count_ways(12) == 2131"
        ],
        "challenge_test_list": []
    }
        {
        "text": "Write a python function to check whether the two numbers differ at one bit position only or not.",
        "code": "def is_Power_Of_Two (x): \r\n    return x and (not(x & (x - 1))) \r\ndef differ_At_One_Bit_Pos(a,b): \r\n    return is_Power_Of_Two(a ^ b)",
        "task_id": 6,
        "test_setup_code": "",
        "test_list": [
            "assert differ_At_One_Bit_Pos(13,9) == True",
            "assert differ_At_One_Bit_Pos(15,8) == False",
            "assert differ_At_One_Bit_Pos(2,4) == False"
        ],
        "challenge_test_list": []
    }
        {
        "text": "Write a function to find all words which are at least 4 characters long in a string by using regex.",
        "code": "import re\r\ndef find_char_long(text):\r\n  return (re.findall(r\"\\b\\w{4,}\\b\", text))",
        "task_id": 7,
        "test_setup_code": "",
        "test_list": [
            "assert find_char_long('Please move back to stream') == ['Please', 'move', 'back', 'stream']",
            "assert find_char_long('Jing Eco and Tech') == ['Jing', 'Tech']",
            "assert find_char_long('Jhingai wulu road Zone 3') == ['Jhingai', 'wulu', 'road', 'Zone']"
        ],
        "challenge_test_list": []
    }
        {
        "text": "Write a function to find squares of individual elements in a list using lambda function.",
        "code": "def square_nums(nums):\r\n square_nums = list(map(lambda x: x ** 2, nums))\r\n return square_nums",
        "task_id": 8,
        "test_setup_code": "",
        "test_list": [
            "assert square_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])==[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]",
            "assert square_nums([10,20,30])==([100,400,900])",
            "assert square_nums([12,15])==([144,225])"
        ],
        "challenge_test_list": []
    }
        {
        "text": "Write a python function to find the minimum number of rotations required to get the same string.",
        "code": "def find_Rotations(str): \r\n    tmp = str + str\r\n    n = len(str) \r\n    for i in range(1,n + 1): \r\n        substring = tmp[i: i+n] \r\n        if (str == substring): \r\n            return i \r\n    return n ",
        "task_id": 9,
        "test_setup_code": "",
        "test_list": [
            "assert find_Rotations(\"aaaa\") == 1",
            "assert find_Rotations(\"ab\") == 2",
            "assert find_Rotations(\"abc\") == 3"
        ],
        "challenge_test_list": []
    }
        {
        "text": "Write a function to get the n smallest items from a dataset.",
        "code": "import heapq\r\ndef small_nnum(list1,n):\r\n  smallest=heapq.nsmallest(n,list1)\r\n  return smallest",
        "task_id": 10,
        "test_setup_code": "",
        "test_list": [
            "assert small_nnum([10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100],2)==[10,20]",
            "assert small_nnum([10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100],5)==[10,20,20,40,50]",
            "assert small_nnum([10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100],3)==[10,20,20]"
        ],
        "challenge_test_list": []
    }
        {
        "text": "Write a python function to remove first and last occurrence of a given character from the string.",
        "code": "def remove_Occ(s,ch): \r\n    for i in range(len(s)): \r\n        if (s[i] == ch): \r\n            s = s[0 : i] + s[i + 1:] \r\n            break\r\n    for i in range(len(s) - 1,-1,-1):  \r\n        if (s[i] == ch): \r\n            s = s[0 : i] + s[i + 1:] \r\n            break\r\n    return s ",
        "task_id": 11,
        "test_setup_code": "",
        "test_list": [
            "assert remove_Occ(\"hello\",\"l\") == \"heo\"",
            "assert remove_Occ(\"abcda\",\"a\") == \"bcd\"",
            "assert remove_Occ(\"PHP\",\"P\") == \"H\""
        ],
        "challenge_test_list": [
            "assert remove_Occ(\"hellolloll\",\"l\") == \"helollol\"",
            "assert remove_Occ(\"\",\"l\") == \"\""
        ]
    }
        {
        "text": "Write a function to sort a given matrix in ascending order according to the sum of its rows.",
        "code": "def sort_matrix(M):\r\n    result = sorted(M, key=sum)\r\n    return result",
        "task_id": 12,
        "test_setup_code": "",
        "test_list": [
            "assert sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]])==[[1, 1, 1], [1, 2, 3], [2, 4, 5]]",
            "assert sort_matrix([[1, 2, 3], [-2, 4, -5], [1, -1, 1]])==[[-2, 4, -5], [1, -1, 1], [1, 2, 3]]",
            "assert sort_matrix([[5,8,9],[6,4,3],[2,1,4]])==[[2, 1, 4], [6, 4, 3], [5, 8, 9]]"
        ],
        "challenge_test_list": []
    }
        {
        "text": "Write a function to count the most common words in a dictionary.",
        "code": "from collections import Counter\r\ndef count_common(words):\r\n  word_counts = Counter(words)\r\n  top_four = word_counts.most_common(4)\r\n  return (top_four)\r\n",
        "task_id": 13,
        "test_setup_code": "",
        "test_list": [
            "assert count_common(['red','green','black','pink','black','white','black','eyes','white','black','orange','pink','pink','red','red','white','orange','white',\"black\",'pink','green','green','pink','green','pink','white','orange',\"orange\",'red']) == [('pink', 6), ('black', 5), ('white', 5), ('red', 4)]",
            "assert count_common(['one', 'two', 'three', 'four', 'five', 'one', 'two', 'one', 'three', 'one']) == [('one', 4), ('two', 2), ('three', 2), ('four', 1)]",
            "assert count_common(['Facebook', 'Apple', 'Amazon', 'Netflix', 'Google', 'Apple', 'Netflix', 'Amazon']) == [('Apple', 2), ('Amazon', 2), ('Netflix', 2), ('Facebook', 1)]"
        ],
        "challenge_test_list": []
    }
        {
        "text": "Write a python function to find the volume of a triangular prism.",
        "code": "def find_Volume(l,b,h) : \r\n    return ((l * b * h) / 2) ",
        "task_id": 14,
        "test_setup_code": "",
        "test_list": [
            "assert find_Volume(10,8,6) == 240",
            "assert find_Volume(3,2,2) == 6",
            "assert find_Volume(1,2,1) == 1"
        ],
        "challenge_test_list": []
    }
        {
        "text": "Write a function to split a string at lowercase letters.",
        "code": "import re\r\ndef split_lowerstring(text):\r\n return (re.findall('[a-z][^a-z]*', text))",
        "task_id": 15,
        "test_setup_code": "",
        "test_list": [
            "assert split_lowerstring(\"AbCd\")==['bC','d']",
            "assert split_lowerstring(\"Python\")==['y', 't', 'h', 'o', 'n']",
            "assert split_lowerstring(\"Programming\")==['r', 'o', 'g', 'r', 'a', 'm', 'm', 'i', 'n', 'g']"
        ],
        "challenge_test_list": []
    }
        {
        "text": "Write a function to find sequences of lowercase letters joined with an underscore.",
        "code": "import re\r\ndef text_lowercase_underscore(text):\r\n        patterns = '^[a-z]+_[a-z]+$'\r\n        if re.search(patterns,  text):\r\n                return 'Found a match!'\r\n        else:\r\n                return('Not matched!')",
        "task_id": 16,
        "test_setup_code": "",
        "test_list": [
            "assert text_lowercase_underscore(\"aab_cbbbc\")==('Found a match!')",
            "assert text_lowercase_underscore(\"aab_Abbbc\")==('Not matched!')",
            "assert text_lowercase_underscore(\"Aaab_abbbc\")==('Not matched!')"
        ],
        "challenge_test_list": [
            "assert text_lowercase_underscore(\"aab-cbbbc\")==('Not matched!')"
        ]
    }
        {
        "text": "Write a function to find the perimeter of a square.",
        "code": "def square_perimeter(a):\r\n  perimeter=4*a\r\n  return perimeter",
        "task_id": 17,
        "test_setup_code": "",
        "test_list": [
            "assert square_perimeter(10)==40",
            "assert square_perimeter(5)==20",
            "assert square_perimeter(4)==16"
        ],
        "challenge_test_list": []
    }
        {
        "text": "Write a function to remove characters from the first string which are present in the second string.",
        "code": "NO_OF_CHARS = 256\r\ndef str_to_list(string): \r\n\ttemp = [] \r\n\tfor x in string: \r\n\t\ttemp.append(x) \r\n\treturn temp \r\ndef lst_to_string(List): \r\n\treturn ''.join(List) \r\ndef get_char_count_array(string): \r\n\tcount = [0] * NO_OF_CHARS \r\n\tfor i in string: \r\n\t\tcount[ord(i)] += 1\r\n\treturn count \r\ndef remove_dirty_chars(string, second_string): \r\n\tcount = get_char_count_array(second_string) \r\n\tip_ind = 0\r\n\tres_ind = 0\r\n\ttemp = '' \r\n\tstr_list = str_to_list(string) \r\n\twhile ip_ind != len(str_list): \r\n\t\ttemp = str_list[ip_ind] \r\n\t\tif count[ord(temp)] == 0: \r\n\t\t\tstr_list[res_ind] = str_list[ip_ind] \r\n\t\t\tres_ind += 1\r\n\t\tip_ind+=1\r\n\treturn lst_to_string(str_list[0:res_ind]) ",
        "task_id": 18,
        "test_setup_code": "",
        "test_list": [
            "assert remove_dirty_chars(\"probasscurve\", \"pros\") == 'bacuve'",
            "assert remove_dirty_chars(\"digitalindia\", \"talent\") == 'digiidi'",
            "assert remove_dirty_chars(\"exoticmiles\", \"toxic\") == 'emles' "
        ],
        "challenge_test_list": []
    }
        {
        "text": "Write a function to find whether a given array of integers contains any duplicate element.",
        "code": "def test_duplicate(arraynums):\r\n    nums_set = set(arraynums)    \r\n    return len(arraynums) != len(nums_set)     ",
        "task_id": 19,
        "test_setup_code": "",
        "test_list": [
            "assert test_duplicate(([1,2,3,4,5]))==False",
            "assert test_duplicate(([1,2,3,4, 4]))==True",
            "assert test_duplicate([1,1,2,2,3,3,4,4,5])==True"
        ],
        "challenge_test_list": []
    }
        {
        "text": "Write a function to check if the given number is woodball or not.",
        "code": "def is_woodall(x): \r\n\tif (x % 2 == 0): \r\n\t\treturn False\r\n\tif (x == 1): \r\n\t\treturn True\r\n\tx = x + 1 \r\n\tp = 0\r\n\twhile (x % 2 == 0): \r\n\t\tx = x/2\r\n\t\tp = p + 1\r\n\t\tif (p == x): \r\n\t\t\treturn True\r\n\treturn False",
        "task_id": 20,
        "test_setup_code": "",
        "test_list": [
            "assert is_woodall(383) == True",
            "assert is_woodall(254) == False",
            "assert is_woodall(200) == False"
        ],
        "challenge_test_list": [
            "assert is_woodall(32212254719) == True",
            "assert is_woodall(32212254718) == False",
            "assert is_woodall(159) == True"
        ]
    }
        {
        "text": "Write a function to find m number of multiples of n.",
        "code": "def multiples_of_num(m,n): \r\n    multiples_of_num= list(range(n,(m+1)*n, n)) \r\n    return list(multiples_of_num)",
        "task_id": 21,
        "test_setup_code": "",
        "test_list": [
            "assert multiples_of_num(4,3)== [3,6,9,12]",
            "assert multiples_of_num(2,5)== [5,10]",
            "assert multiples_of_num(9,2)== [2,4,6,8,10,12,14,16,18]"
        ],
        "challenge_test_list": []
    }
        {
        "text": "Write a function to find the first duplicate element in a given array of integers.",
        "code": "def find_first_duplicate(nums):\r\n    num_set = set()\r\n    no_duplicate = -1\r\n\r\n    for i in range(len(nums)):\r\n\r\n        if nums[i] in num_set:\r\n            return nums[i]\r\n        else:\r\n            num_set.add(nums[i])\r\n\r\n    return no_duplicate",
        "task_id": 22,
        "test_setup_code": "",
        "test_list": [
            "assert find_first_duplicate(([1, 2, 3, 4, 4, 5]))==4",
            "assert find_first_duplicate([1, 2, 3, 4])==-1",
            "assert find_first_duplicate([1, 1, 2, 3, 3, 2, 2])==1"
        ],
        "challenge_test_list": []
    }
        {
        "text": "Write a python function to find the maximum sum of elements of list in a list of lists.",
        "code": "def maximum_Sum(list1): \r\n    maxi = -100000\r\n    for x in list1: \r\n        sum = 0 \r\n        for y in x: \r\n            sum+= y      \r\n        maxi = max(sum,maxi)     \r\n    return maxi ",
        "task_id": 23,
        "test_setup_code": "",
        "test_list": [
            "assert maximum_Sum([[1,2,3],[4,5,6],[10,11,12],[7,8,9]]) == 33",
            "assert maximum_Sum([[0,1,1],[1,1,2],[3,2,1]]) == 6",
            "assert maximum_Sum([[0,1,3],[1,2,1],[9,8,2],[0,1,0],[6,4,8]]) == 19"
        ],
        "challenge_test_list": [
            "assert maximum_Sum([[0,-1,-1],[-1,-1,-2],[-3,-2,-1]]) == -2"
        ]
    }
        {
        "text": "Write a function to convert the given binary number to its decimal equivalent.",
        "code": "def binary_to_decimal(binary): \r\n    binary1 = binary \r\n    decimal, i, n = 0, 0, 0\r\n    while(binary != 0): \r\n        dec = binary % 10\r\n        decimal = decimal + dec * pow(2, i) \r\n        binary = binary//10\r\n        i += 1\r\n    return (decimal)",
        "task_id": 24,
        "test_setup_code": "",
        "test_list": [
            "assert binary_to_decimal(100) == 4",
            "assert binary_to_decimal(1011) == 11",
            "assert binary_to_decimal(1101101) == 109"
        ],
        "challenge_test_list": []
    }
        {
        "text": "Write a python function to find the product of non-repeated elements in a given array.",
        "code": "def find_Product(arr,n): \r\n    arr.sort() \r\n    prod = 1\r\n    for i in range(0,n,1): \r\n        if (arr[i - 1] != arr[i]): \r\n            prod = prod * arr[i] \r\n    return prod; ",
        "task_id": 25,
        "test_setup_code": "",
        "test_list": [
            "assert find_Product([1,1,2,3],4) == 6",
            "assert find_Product([1,2,3,1,1],5) == 6",
            "assert find_Product([1,1,4,5,6],5) == 120"
        ],
        "challenge_test_list": [
            "assert find_Product([1,1,4,5,6,5,7,1,1,3,4],11) == 2520"
        ]
    }
        {
        "text": "Write a function to check if the given tuple list has all k elements.",
        "code": "def check_k_elements(test_list, K):\r\n  res = True\r\n  for tup in test_list:\r\n    for ele in tup:\r\n      if ele != K:\r\n        res = False\r\n  return (res) ",
        "task_id": 26,
        "test_setup_code": "",
        "test_list": [
            "assert check_k_elements([(4, 4), (4, 4, 4), (4, 4), (4, 4, 4, 4), (4, )], 4) == True",
            "assert check_k_elements([(7, 7, 7), (7, 7)], 7) == True",
            "assert check_k_elements([(9, 9), (9, 9, 9, 9)], 7) == False"
        ],
        "challenge_test_list": [
            "assert check_k_elements([(4, 4), (4, 4, 4), (4, 4), (4, 4, 6, 4), (4, )], 4) == False"
        ]
    }
        {
        "text": "Write a python function to remove all digits from a list of strings.",
        "code": "import re  \r\ndef remove(list): \r\n    pattern = '[0-9]'\r\n    list = [re.sub(pattern, '', i) for i in list] \r\n    return list",
        "task_id": 27,
        "test_setup_code": "",
        "test_list": [
            "assert remove(['4words', '3letters', '4digits']) == ['words', 'letters', 'digits']",
            "assert remove(['28Jan','12Jan','11Jan']) == ['Jan','Jan','Jan']",
            "assert remove(['wonder1','wonder2','wonder3']) == ['wonder','wonder','wonder']"
        ],
        "challenge_test_list": []
    }
        {
        "text": "Write a python function to find binomial co-efficient.",
        "code": "def binomial_Coeff(n,k): \r\n    if k > n : \r\n       return 0\r\n    if k==0 or k ==n : \r\n        return 1 \r\n    return binomial_Coeff(n-1,k-1) + binomial_Coeff(n-1,k) ",
        "task_id": 28,
        "test_setup_code": "",
        "test_list": [
            "assert binomial_Coeff(5,2) == 10",
            "assert binomial_Coeff(4,3) == 4",
            "assert binomial_Coeff(3,2) == 3"
        ],
        "challenge_test_list": [
            "assert binomial_Coeff(14,6) == 3003"
        ]
    }
}
```





# 收集到的函数整理

## Python语言



```python
import marshal
import math
from difflib import get_close_matches
from pathlib import Path
from random import random
from typing import Any


def merge_sorted_arrays(arr1: list[int], arr2: list[int]) -> list[int]:
    """合并两个有序数组

    Parameters
    ----------
    arr1
        有序数组1
    arr2
        有序数组2

    Returns
    -------
        合并后的数组
    """
    i = 0
    j = 0
    res = []
    while i < len(arr1) and j < len(arr2):
        if arr1[i] < arr2[j]:
            res.append(arr1[i])
            i += 1
        else:
            res.append(arr2[j])
            j += 1
    if i < len(arr1):
        res += arr1[i:]
    if j < len(arr2):
        res += arr2[j:]

    return res


def elo_rating(rating1: float, rating2: float, ep: float, rounds: int = 0) -> tuple[float, float]:
    """计算两个队伍的elo评分

    Parameters
    ----------
    rating1
        队伍1的elo评分
    rating2
        队伍2的elo评分
    ep
        真实胜率
    rounds, optional
        同一时间对战轮数, by default 0

    Returns
    -------
        两队的赛后评分
    """
    k = 32
    k_corrs = math.pow(0.9, rounds)

    delta = rating1 - rating2 if ep > 0.5 else rating2 - rating1
    # 分差修正公式
    corr_m = 2.2 / (delta * 0.001 + 2.2)

    prob1 = 1 / (1 + math.pow(10, (rating2 - rating1) / 400))
    prob2 = 1 / (1 + math.pow(10, (rating1 - rating2) / 400))

    rating1 += (ep - prob1) * k * corr_m * k_corrs
    rating2 += (1 - ep - prob2) * k * corr_m * k_corrs

    return rating1, rating2


class ArmyGenerator:
    """阵容生成器"""

    def __init__(self, folder: str) -> None:
        try:
            self._p = Path(folder)
            self._filelst = list(self._p.iterdir())

        except ValueError as e:
            print(f"Error: {e}|无法连接到文件夹{folder}")

    @staticmethod
    def _read_file(filepath: Path) -> dict[str, Any]:
        """读取army文件

        Parameters
        ----------
        filepath
            文件路径

        Returns
        -------
            阵容字典
        """
        data = None
        with open(filepath, "rb") as fi:
            data = marshal.load(fi)
        return data

    @staticmethod
    def _extract_army(army: dict[str, Any]) -> tuple[str, list]:
        """提取阵容信息

        Parameters
        ----------
        army
            阵容字典

        Returns
        -------
            兵种和武将列表
        """
        troop_type = army.get("troop_type", 0)
        if general_data := army.get("general_data", None):
            general_lst = []
            for k in sorted(general_data.keys()):
                general_id = general_data[k]["general_id"]
                if skills := general_data[k].get("skills", None):
                    re_skills = [skill[1] for skill in skills]
                    re_skills[1:] = sorted(re_skills[1:])
                general_lst.append((general_id, re_skills))
        return troop_type, general_lst

    @property
    def filelist(self) -> list[Path]:
        """返回文件列表

        Returns
        -------
            文件列表
        """
        return self._filelst

    def random_army(self) -> tuple[str, list]:
        """随机生成阵容"""
        army = self._read_file(random.choice(self._filelst))
        return self._extract_army(army)

    def pick_army(self, query_txt: str = None) -> tuple[str, list]:
        """根据查询文本选择阵容"""
        if not query_txt:
            return self.random_army()
        name_lst = [f.name for f in self._filelst]
        match_lst = get_close_matches(query_txt, name_lst, cutoff=0.1)
        if len(match_lst) <= 0:
            return self.random_army()
        army = self._read_file(self._p / match_lst[0])
        return self._extract_army(army)


if __name__ == "__main__":
    # test merge_sorted_arrays
    test_arr1 = [1, 3, 9, 12, 35, 66, 99]
    test_arr2 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    print(merge_sorted_arrays(test_arr1, test_arr2))

    # test elo_rating
    rating1 = 1000
    rating2 = 1200
    ep = 0.4
    rounds = 2
    print(elo_rating(rating1, rating2, ep, rounds))
```



```python
def train(net, train_iter, test_iter, num_epochs, lr, device):
    def init_weights(m):
        if type(m) == torch.nn.Linear or type(m) == torch.nn.Conv2d:
            torch.nn.init.xavier_uniform_(m.weight)
    net.apply(init_weights)
    print('training on', device)
    net.to(device)
    optimizer = torch.optim.SGD(net.parameters(), lr=lr)
    loss = torch.nn.CrossEntropyLoss()

    history = {
        'train_l': [],
        'train_acc': [],
        'test_acc': [],
    }
    fig, ax = plt.subplots(figsize=(5, 5))
    for epoch in range(num_epochs):
        metrics = []
        times = []
        times_data = []

        net.train()
        start = time.time()

        for i, (X, y) in enumerate(train_iter):
            times_data.append(time.time() - start)
            optimizer.zero_grad()
            X, y = X.to(device), y.to(device)
            y_hat = net(X)
            l = loss(y_hat, y)
            l.backward()
            optimizer.step()
            with torch.no_grad():
                metrics.append((l * X.shape[0], accuracy(y, y_hat), X.shape[0]))
            times.append(time.time() - start)

            train_l = sum(l for l, a, t in metrics) / sum(t for l, a, t in metrics)
            train_acc = sum(a for l, a, t in metrics) / sum(t for l, a, t in metrics)
            start = time.time()

        test_acc = evaluate_accuracy_gpu(net, test_iter, device)
        history['train_l'].append(train_l.cpu().item())
        history['train_acc'].append(train_acc)
        history['test_acc'].append(test_acc)

        display.clear_output(wait=True)
        ax.cla()
        ax.plot(range(1, len(history['train_l'])+1), history['train_l'])
        ax.plot(range(1, len(history['train_acc'])+1), history['train_acc'])
        ax.plot(range(1, len(history['test_acc'])+1), history['test_acc'])
        ax.set_xlim(1, num_epochs)
        ax.set_ylim(0, 3)
        ax.grid(True)
        ax.legend(['train_loss', 'train_acc', "test_acc"])
        display.display(fig)

        print(f"epoch({epoch+1}/{num_epochs}): train_l({train_l}), train_acc({train_acc}), test_acc({test_acc}), time({sum(times)}) datatime({sum(times_data)})")



def linepoints(x1, y1, x2, y2):
    # generate points with two float points
    points = []

    dx = x2 - x1
    dy = y2 - y1
    steep = abs(dx) < abs(dy)
    if steep:
        x1, y1 = y1, x1
        x2, y2 = y2, x2
        dx, dy = dy, dx
    sign = 1 if x2 > x1 else -1

    sx = int(x1 + 0.5 * sign)
    ex = int(x2 - 0.5 * sign)
    de = dy / dx
    y = y1 + de * (sx + 0.5 - x1)

    points.append((int(y1), int(x1)) if steep else (int(x1), int(y1)))
    for x in range(sx, ex + sign, sign):
        points.append((int(y), x) if steep else (x, int(y)))
        y += de * sign
    points.append((int(y2), int(x2)) if steep else (int(x2), int(y2)))

    return points



def VoronoiDiagram():
    width, height = 512, 512

    img = Image.new("RGB", (width, height), (50, 50, 50))
    draw = ImageDraw.Draw(img)

    points = []
    for i in range(100):
        x = random.uniform(0, width)
        y = random.uniform(0, height)
        points.append((x, y))

    for (x, y) in points:
        draw.point((x, y), fill='red')

    vp = voronoi.Voronoi(points)
    vp.process()
    print(vp.event)

    lines = vp.get_output()
    print(lines)

    for line in lines:
        draw.line(line, fill='yellow', width=2)



def ssim(img1, img2):
    '''structural similarity index'''
    C1 = (0.01 * 255)**2
    C2 = (0.03 * 255)**2

    img1 = img1.astype(np.float64)
    img2 = img2.astype(np.float64)
    kernel = cv2.getGaussianKernel(11, 1.5)
    window = np.outer(kernel, kernel.transpose())

    mu1 = cv2.filter2D(img1, -1, window)[5:-5, 5:-5]  # valid
    mu2 = cv2.filter2D(img2, -1, window)[5:-5, 5:-5]
    mu1_sq = mu1**2
    mu2_sq = mu2**2
    mu1_mu2 = mu1 * mu2
    sigma1_sq = cv2.filter2D(img1**2, -1, window)[5:-5, 5:-5] - mu1_sq
    sigma2_sq = cv2.filter2D(img2**2, -1, window)[5:-5, 5:-5] - mu2_sq
    sigma12 = cv2.filter2D(img1 * img2, -1, window)[5:-5, 5:-5] - mu1_mu2

    ssim_map = ((2 * mu1_mu2 + C1) * (2 * sigma12 + C2)) / ((mu1_sq + mu2_sq + C1) *
                                                            (sigma1_sq + sigma2_sq + C2))
    return ssim_map.mean()



def atlas_to_sprite(fpath, debug=False):
    pixel2area = {}
    area_cnt = 0
    with Image.open(fpath) as im:
        width, height = im.size
        area = []
        def flood_fill(x, y, color):
            queue = [(x, y)]
            while queue:
                x, y = queue.pop()
                area.append((x, y))
                pixel2area[(x, y)] = color
                for nx, ny in [(x-1, y), (x, y-1), (x+1, y), (x, y+1)]:
                    if (nx, ny) in pixel2area or nx < 0 or nx >=width or ny < 0 or ny >= height:
                        continue
                    if im.getpixel((nx, ny))[3] > 50:
                        queue.append((nx, ny))
                    else:
                        area.append((nx, ny))

        for px, py in product(range(width), range(height)):
            if (px, py) not in pixel2area and im.getpixel((px, py))[3] == 255:
                area = []
                flood_fill(px, py, area_cnt)
                area_cnt += 1
                minx = min(x for (x, y) in area)
                maxx = max(x for (x, y) in area)
                miny = min(y for (x, y) in area)
                maxy = max(y for (x, y) in area)
                maxx = maxx + 1 if maxx < width-1 else maxx
                maxy = maxy + 1 if maxy < height-1 else maxy
                if (maxx - minx) > 64 and (maxy - miny) > 64:
                    cropim = im.crop([minx, miny, maxx, maxy])
                    print([minx, miny, maxx, maxy])
                    print(cropim.size)
                    area = set(area)
                    for cx, cy in product(range(cropim.size[0]), range(cropim.size[1])):
                        if (cx+minx, cy+miny) not in area:
                            cropim.putpixel((cx, cy), (0, 0, 0, 0))
                    if debug:
                        handle_crop(cropim)
                    cropim.save(fpath.replace('.png', f'_{area_cnt}.png'))



def draw_line():
    x = np.linspace(0, 2, 100)

    fig, ax = plt.subplots(figsize=(5, 2.7), layout='constrained')
    ax.plot(x, x, label='linear')
    ax.plot(x, x**2, label='quadratic')
    ax.plot(x, x**3, label='cubic')
    ax.set_xlabel('x label')
    ax.set_ylabel('y label')
    ax.set_title('Simple Plot')
    ax.legend()



def CreateHexFogSprite(self, rc, isInSideEdge):
    import commonres
    rootNode = self.m_FogPipLine.GetScene()

    if isInSideEdge:
        idx = misc.RandInt(1, 2)
    else:
        idx = misc.RandInt(1, 5)

    if isInSideEdge:
        randScale = (misc.RandInt(1, 10) - 3) / 100.0
    else:
        randScale = (misc.RandInt(1, 30) - 10) / 100.0
    fScale = 0.5 + randScale

    oSprite = commonres.MazeFogId2Sprite(idx)
    oSprite = SetAnchorPoint(0.5, 0.5)
    oSprite.SetScale(fScale)
    oSprite.SetPos(*HEX_SHAPE.HexCenterRC2XY(*rc))
    oSprite.SetParent(rootNode)
    oSprite.IsInSideEdge = isInSideEdge
    self.m_HexFogGrids[rc] = oSprite

    disx = misc.RnadInt(1, 30) - 15
    disy = misc.RandInt(1, 30) - 15
    action = C_object.CMoveBy(6.0, disx, disy)
    action2 = C_object.CMoveBy(6.0 -disx, -disy)
    oSprite.RunAction(C_object.CRepeatForever(C_object.CSequence([action, action2])))
```



```python

# 最短路径
def minDistance(word1, word2):
    m, n = len(word1), len(word2)
    dp = [[-1] * (n + 1) for _ in range(m + 1)]
    dp[0][0] = 0
    for i in range(m + 1):
        dp[i][0] = i
    for j in range(n + 1):
        dp[0][j] = j
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if word1[i - 1] == word2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1]
            else:
                dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1
    return dp[m][n]

# 递增路径
def IncreasingPath(matrix):
    m, n = len(matrix), len(matrix[0])
    flag = [[-1] * n for _ in range(m)]  # 存储从（i，j）出发的最长递归路径

    # 寻找节点的最长路径
    def dfs(i, j):
        d = 1
        # 最长路径已知（记忆化搜索，避免重复的计算）
        if flag[i][j] != -1:
            d = flag[i][j]
        else:
            for (x, y) in [[-1, 0], [1, 0], [0, 1], [0, -1]]:
                x, y = i + x, j + y
                if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:
                    d = max(d, dfs(x, y) + 1)  # 取四个邻接点的最长
        flag[i][j] = d  # 在该节点上记录其所需最大路径长度
        return d

    res = 0
    for i in range(m):  # 遍历矩阵计算最长路径
        for j in range(n):
            if flag[i][j] == -1:
                res = max(res, dfs(i, j))
    return res

# 宽度为 K 的窗口
def window(List, K):
    window = []
    for i in range(len(List) - K + 1):
        res = []
        for j in range(K):
            res.append(List[i + j])
        window.append(res)
    return window

# 最大值
def max_num(List):
    MAX = []
    if len(List) == 0:
        return print("The List is empty!")
    else:
        for i in range(len(List)):
            max_Num = List[i][0]
            for j in range(len(List[i])):
                if max_Num < List[i][j]:
                    max_Num = List[i][j]
            MAX.append(max_Num)
        return MAX

# 求最大面积
def maximalRectangle(rows, cols, List):
    res = [0]
    for i in range(rows):
        for j in range(cols):
            H = List[i][j]
            D = 1
            L = j - 1
            R = j + 1
            while (L >= 0) and (H <= List[i][L]):
                L -= 1
                D += 1
            while (R < cols) and (H <= List[i][R]):
                R += 1
                D += 1
            res.append(D * H)
    return max(res)

# 求矩形面积
def ectangleArea(matrix):
    res = []
    if matrix == []:
        rows = 0
        cols = 0
    else:
        rows = len(matrix)
        cols = len(matrix[0])
        for i in range(rows):
            height = [0] * cols
            stop = [False] * cols
            I = i + 1
            while I:
                for j in range(cols):
                    if matrix[I - 1][j] == '1' and (not stop[j]):
                        height[j] += 1
                    else:
                        stop[j] = True
                I -= 1
            res.append(height)
    return rows, cols, res

# 拆分棋子，返回（棋子编号及其索引）
def spliting(str, num):
    B, R = [], []
    str = list(str)
    for i in range(len(str)):
        if str[i] == 'B':
            B.append([num[i], i])
        else:
            R.append([num[i], i])
    return B, R

# 去掉交换后最大的棋子
def delete(B, R):
    max_B, max_Bi = 0, 0
    for i in range(len(B)):
        Bi = B[i][0]
        # 获取最大值位置
        if max_B < Bi:
            max_B = Bi
            max_Bi = i
    if max_Bi == (len(B) - 1):
        B.pop(-1)
        N = 0
    else:
        N = B[-1][-1] - B[max_Bi][-1]
    if N != 0:
        B1 = []
        R1 = []
        for j in range(len(B)):
            if B[j][-1] > B[max_Bi][-1]:
                B1.append([B[j][0], B[j][-1] - 1])
            else:
                B1.append(B[j])
        B = B1
        for j in range(len(R)):
            if R[j][-1] > B[max_Bi][-1]:
                R1.append([R[j][0], R[j][-1] - 1])
            else:
                R1.append(R[j])
        R = R1
        B.pop(max_Bi)
    return B, R, N

# 元组的异或值
def XORed(tuple):
    X0 = tuple[0]
    for i in range(len(tuple)):
        if i >= 1:
            X0 ^= tuple[i]
    return X0

# 大楼轮廓线
def contour_line(Line):
    Line_div = []  # 轮廓线分割
    Num = []  # 下标
    res = []  # 单位轮廓线（唯一）
    result = []  # 最终轮廓线
    index = len(Line)
    # 将所有大楼进行分割，其横轴间隔为 1
    for i in range(index):
        for j in range(Line[i][0], Line[i][1]):
            Num.append(j)
            Line_div.append([j, j + 1, Line[i][-1]])
    Num = sorted(set(Num))
    # 保留单位横轴中高度最高的区域，即去掉重叠的部分
    for i in range(len(Num)):
        h = 0
        for j in range(len(Line_div)):
            if Line_div[j][0] == Num[i]:
                if Line_div[j][-1] > h:
                    h = Line_div[j][-1]
        if h != 0:
            res.append([Num[i], Num[i]+1, h])
    res.sort()
    # 将能够连接接（同高度）
    while len(res) >= 2:
        if res[0][1] == res[1][0] and res[0][-1] == res[1][-1]:
            res = [[res[0][0], res[1][1], res[0][-1]]] + res
            del res[1:3]
        else:
            result.append(res[0])
            res.pop(0)
    result.append(res[0])
    return result

# 判断一个数是否为质数
def prime_number(value):
    for i in range(2, value):
        if value % i == 0:
            return False
    return True
```



```python
from __future__ import division, print_function
import math
from random import random
import sys
import os
from io import BytesIO, IOBase
from collections import deque, Counter, OrderedDict, defaultdict
import heapq
# ceil,floor,log,sqrt,factorial,pow,pi,gcd
import bisect
from bisect import bisect_left,bisect_right
 
BUFSIZE = 8192


class FastIO(IOBase):
    # 快读函数
	newlines = 0
 
	def __init__(self, file):
		self._fd = file.fileno()
		self.buffer = BytesIO()
		self.writable = "x" in file.mode or "r" not in file.mode
		self.write = self.buffer.write if self.writable else None
 
	def read(self):
		while True:
			b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
			if not b:
				break
			ptr = self.buffer.tell()
			self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
		self.newlines = 0
		return self.buffer.read()
 
	def readline(self):
		while self.newlines == 0:
			b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
			self.newlines = b.count(b"\n") + (not b)
			ptr = self.buffer.tell()
			self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
		self.newlines -= 1
		return self.buffer.readline()
 
	def flush(self):
		if self.writable:
			os.write(self._fd, self.buffer.getvalue())
			self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    # 快写函数
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode("ascii"))
        self.read = lambda: self.buffer.read().decode("ascii")
        self.readline = lambda: self.buffer.readline().decode("ascii") 

class MinSegmentTree:
    # 最小生成树
    def __init__(self, data, default=float('inf'), func=min):
        """initialize the segment tree with data"""
        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()
 
        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])
 
    def __delitem__(self, idx):
        self[idx] = self._default
 
    def __getitem__(self, idx):
        return self.data[idx + self._size]
 
    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1
 
    def __len__(self):
        return self._len
 
    def query(self, start, stop):
        """func of data[start, stop)"""
        start += self._size
        stop += self._size
 
        res_left = res_right = self._default
        while start < stop:
            if start & 1:
                res_left = self._func(res_left, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res_right = self._func(self.data[stop], res_right)
            start >>= 1
            stop >>= 1
 
        return self._func(res_left, res_right)
 
    def __repr__(self):
        return "SegmentTree({0})".format(self.data)

class triangle(object):
    def __init__(self, a, b ,c) -> None:
         self.a = a
         self.b = b
         self.c = c
    
    def isTriPrint(self):
        print(self.isTri())

    def isTri(self):
        str = ""
        if self.a>0 and self.b>0 and self.c>0 and self.a+self.b>self.c and self.a+self.c>self.b and self.b+self.c>self.a:
            str = '能组成三角形, '
            if self.a==self.b==self.c:
                str += '等边三角形'
            elif self.a==self.b or self.a==self.c or self.b==self.c:
                str += '等腰三角形'
            elif (self.a**2+self.b**2==self.c**2) or (self.b**2+self.c**2==self.a**2) or (self.a**2+self.c**2==self.b**2):
                str += '直角三角形'
            else:
                str += '普通三角形'
        else:
                str = '不能组成三角形'
        return str
    
def find_max_in_array(a):
    # 求dict或list最大值
    if type(a)==list:
        return max(a)
    if type(a)==dict:
        return max(a, key=a.get)

def draw_sin_cos():
    import matplotlib.pyplot as plt
    import numpy as np
    from jupyterthemes import jtplot
    jtplot.style(grid=False)

    x = np.linspace(-2, np.pi)
    y1 = np.sin(x)
    y2 = np.cos(x)

    plt.figure(num=2,figsize=(8,5))
    plt.plot(x,y2)
    plt.plot(x,y1,color='red',linewidth=1.0,linestyle='--')
    plt.show()

def iftorch():
    import torch
    print(torch.__version__)
    print(torch.cuda.is_available())

def cv_show_img(path):
    import cv2
    image = cv2.imread(path,0)
    cv2.imshow("显示图片："+ path,image)
    cv2.waitKey()
    cv2.destroyAllWindows()

def generate_points(num, tn):
    from random import randint
    return [[i + randint(-1, 1), j + randint(-1, 1)]for i in range(0, num, tn) for j in range(0, num, tn)]


if __name__ == '__main__':
    # 列表输出最大值并排序
    list_num = [2,4,8,5,6,10]
    print(find_max_in_array(list_num))
    list_num.sort()
    print(list_num)

    # 字典输出最大值并排序
    dict_num = {"alice":37, "sun":22, "zhang":50}
    print(find_max_in_array(dict_num), dict_num[find_max_in_array(dict_num)])
    dict_num_s = sorted(dict_num, key=dict_num.get)
    print(dict_num_s)
    
    # 生成最小生成树
    A = [int(x) for x in "7 4 8 1 6 10 3 5 2 9".split()]
    S1 = MinSegmentTree(data=A)
     
    # 验证三角形种类
    t = triangle(3,4,5)
    t.isTriPrint()

    # 快速读，快速写
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
    input = lambda: sys.stdin.readline().rstrip("\r\n")

    # 画sin(x)与cos(x)图
    draw_sin_cos()

    # 验证pytorch是否启用gpu
    iftorch()

    # 读取图片
    cv_show_img("123.bmp")

    # 生成随机类矩阵点图, 10x10
    list_points = generate_points(100, 5)
    print(list_points)
```









## C语言



```python
#include <stdio.h>
#include <stdlib.h>

typedef struct node
{
    int id;
    struct node *next;
} NODE, *LinkList;

LinkList create_list(int n)
{
    LinkList head, p;
    int k;
    head = (LinkList)malloc(sizeof(NODE)); /* 创建循环列表的第一个结点 */
    if (!head)
    {
        printf("内存分配失败！\n");
        return NULL;
    }
    head->id = 1;
    head->next = head;
    for (k = n; k > 1; --k)
    {
        /* 头插法创建循环列表的其余n-1个结点 */
        p = (LinkList)malloc(sizeof(NODE));
        if (!p)
        {
            printf("内存分配失败！\n");
            return NULL;
        }
        p->id = k;
        p->next = head->next;
        head->next = p;
    }
    return head;
}

void play(LinkList head, int n)
{
    LinkList p, s;
    int c, k;
    p = head;
    c = 1;
    k = n;
    while (k > 1)
    {
        if (c = 2)
        {
            s = p->next;
            p->next = s->next;
            printf("%4d", s->id);
            free(s);
            c = 0;
            k--;
        }
        c++;
        p = p->next;
    }
    printf("\n%4d 为胜利者", p->id);
}

void output(LinkList head)
{
    LinkList p;
    p = head;
    do
    {
        printf("%4d", p->id);
        p = p->next;
    } while (p != head);
    printf("\n");
}

int main(void)
{
    LinkList headptr;
    int n;
    printf("请输入玩家的数量：");
    scanf("%d", &n);
    headptr = create_list(n);
    if (headptr)
    {
        output(headptr);
        play(headptr, n);
    }
    return 0;
}
```









## JS语言





```javascript
1.实现 pow(x, n) ，即计算 x 的整数 n 次幂函数。
var myPow = function(x, n) {
    if(n < 0) return 1/fastPower(x,-1*n)
    else return fastPower(x,n)
};
var fastPower = function(a,b) {
    let ans = 1
    let k = a
    while(b) {
        if(b%2 === 1) ans*=k
        k*=k
        b=Math.floor(b/2)
    }
    return ans
}


2.给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

说明：每次只能向下或者向右移动一步。

var minPathSum = function(grid) {
    let minCost = [[]]
    let m = grid.length
    let n = grid[0].length
    for(let i = 0; i < m; i++) {
        minCost[i] = {}
        for(let j = 0; j < n; j++) {
            if(i === 0 && j === 0) {
                minCost[i][j] = grid[i][j]
            }else if(i === 0) {
                minCost[i][j] = minCost[i][j - 1] + grid[i][j]
            }else if(j === 0) {
                minCost[i][j] = minCost[i - 1][j] + grid[i][j]
            }else {
                minCost[i][j] = Math.min(minCost[i - 1][j], minCost[i][j - 1]) + grid[i][j]
            }
        }
    }
    return minCost[m - 1][n - 1]
};


3.给你两个二进制字符串，返回它们的和（用二进制表示）。
输入为 非空 字符串且只包含数字 1 和 0。

var addBinary = function(a, b) {
    let sum = []
    a = a.split('')
    b = b.split('')
    let m = a.length - 1, n = b.length - 1
    let carry = 0
    while(m >= 0 && n >= 0) {
        sum.unshift((Number(a[m]) + Number(b[n]) + carry) % 2)
        carry = Math.floor((carry + Number(a[m]) + Number(b[n])) / 2)
        m--
        n--
    }
    while(m >= 0) {
        sum.unshift((Number(a[m]) + carry) % 2)
        carry = Math.floor((carry + Number(a[m])) / 2)
        m--
    }
    while(n >= 0) {
        sum.unshift((Number(b[n]) + carry) % 2)
        carry = Math.floor((carry + Number(b[n])) / 2)
        n--
    }
    if(carry) sum.unshift(1)
    return sum.join('')
};


4.给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。（二分查找）

var search = function(nums, target) {
    let l = 0
    let r = nums.length - 1
    let p = -1
    while(l <= r) {
        var x = Math.floor((l+r)/2)
        if(nums[x] < target) {
            l = x + 1
        }else if(nums[x] > target) {
            r = x - 1
        }else {
            p = x
            break
        }
    }
    return p
};

5.给你一个字符串 s，找到 s 中最长的回文子串。

var longestPalindrome = function(s) {
    let isPalindrome = [[]]
    let maxP = 0, maxL = 1
    for(let i = 0; i < s.length; i++) {
        isPalindrome[i] = {}
        isPalindrome[i][i] = true
    }
    for(let l = 2; l <= s.length; l++) {
        for(let j = 0; j < s.length; j++) {
            if(s[j] != s[j + l - 1]) {
                isPalindrome[j][j + l - 1] = false
            }else if(l <= 3) {
                isPalindrome[j][j + l - 1] = true
            }else {
                isPalindrome[j][j + l - 1] = isPalindrome[j + 1][j + l - 2]
            }
            if(isPalindrome[j][j + l - 1] === true && l > maxL) {
                maxP = j
                maxL = l
            }
        }
    }
    return s.substring(maxP, maxP + maxL)
};
```

